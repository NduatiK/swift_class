# Untitled notebook

```elixir
Mix.install([
  {:ergo, git: "https://github.com/NduatiK/ergo.git", branch: "nk-add-Ergo.Nil"}
])
```

## Section

```elixir
defmodule Combinators do
  alias Ergo.Context
  alias Ergo.Parser

  @doc ~S"""
  The `transform_with_context/2` parser runs a transforming function on the AST of its child parser.

  ## Examples

      # Sum the digits
      iex> alias Ergo.Context
      iex> import Ergo.{Combinators, Terminals}
      iex> digit_to_int = fn d -> List.to_string([d]) |> String.to_integer() end
      iex> t_fn = fn old_ctx, _new_ctx, ast -> "#{ast |> Enum.map(digit_to_int) |> Enum.sum()} on line #{old_ctx.line}" end
      iex> parser = sequence([digit(), digit(), digit(), digit()]) |> Combinators.transform_with_context(t_fn)
      iex> context = Ergo.parse(parser, "1234")
      %Context{status: :ok, ast: "10 on line 1", index: 4, line: 1, col: 5} = context
  """
  def transform_with_context(%Parser{} = parser, transformer_fn, opts \\ [])
      when is_function(transformer_fn) do
    label = Keyword.get(opts, :label, "transform_with_context<#{parser.label}>")

    Parser.combinator(
      :transform_with_context,
      label,
      fn %Context{} = ctx ->
        with %Context{status: :ok} = match_ctx <- Parser.invoke(ctx, parser) do
          match_ctx
          |> Context.ast_transform(fn ast -> transformer_fn.(ctx, match_ctx, ast) end)
        end
      end,
      child_info: Parser.child_info_for_telemetry(parser)
    )
  end

  @doc ~S"""
  Wraps the results of the given parser in a list.

  ## Examples

  iex> import Combinators
  iex> import Ergo.Terminals
  iex> alias Ergo.Context
  iex> parser = wrap(digit())
  iex> context = Ergo.parse(parser, "1")
  %Context{status: :ok, ast: [?1], index: 1, line: 1, col: 2} = context
  """
  def wrap(%Parser{} = parser) do
    Ergo.Combinators.transform(parser, &List.wrap/1)
  end

  @doc ~S"""
  # The `lookahead` parser accepts a parser and matches it but does not update the context when it succeeds.

  # ## Example

  #     iex> alias Ergo.Context
  #     iex> import Ergo.{Combinators, Terminals}
  #     iex> parser = lookahead(literal("Hello"))
  #     iex> assert %Context{status: :ok, ast: nil, input: "Hello World", index: 0} = Ergo.parse(parser, "Hello World")

  #     iex> alias Ergo.Context
  #     iex> import Ergo.{Combinators, Terminals}
  #     iex> parser = lookahead(literal("Helga"))
  #     iex> assert %Context{status: {:fatal, [{:lookahead_fail, {1, 4}, _}, {:bad_literal, {1, 4}, _}, {:unexpected_char, {1, 4}, _}]}, index: 3, col: 4, input: "lo World"} = Ergo.parse(parser, "Hello World")
  """
  def halt(error) do
    Parser.combinator(
      :halt,
      "halt",
      fn %Context{} = ctx ->
        err_ctx = Context.add_error(ctx, :lookahead_fail, error)
        fatal_ctx = %{err_ctx | status: put_elem(err_ctx.status, 0, :fatal)}
        fatal_ctx
      end
    )
  end

  def halt(%Parser{} = parser, error, opts \\ []) do
    label = Keyword.get(opts, :label, "halt<#{parser.label}>")

    Parser.combinator(
      :halt,
      label,
      fn %Context{} = ctx ->
        with %Context{status: :ok} = _new_ctx <- Parser.invoke(ctx, parser) do
          err_ctx = Context.add_error(ctx, :lookahead_fail, error)
          fatal_ctx = %{err_ctx | status: put_elem(err_ctx.status, 0, :fatal)}
          fatal_ctx
        end
      end,
      child_info: Parser.child_info_for_telemetry(parser)
    )
  end
end

defmodule Context do
  def create_annotation(%Ergo.Context{} = old_ctx, %Ergo.Context{} = _new_ctx) do
    if Application.get_env(:live_view_native_stylesheet, :annotations, true) do
      [file: old_ctx.data[:file], line: old_ctx.line, module: old_ctx.data[:module]]
    else
      []
    end
  end
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
defmodule Tokens do
  import Ergo.Terminals
  import Ergo.Combinators
  import Combinators

  @doc """

  iex> Ergo.parse(Tokens.boolean(), "true").ast
  true

  iex> Ergo.parse(Tokens.boolean(), "false").ast
  false

  """
  def boolean() do
    choice([
      replace(literal("true"), true),
      replace(literal("false"), false)
    ])
  end

  @doc """

  iex> Ergo.parse(Tokens.nil_(), "nil").ast
  nil

  """
  def nil_() do
    replace(literal("nil"), nil)
  end

  def minus() do
    optional(char(?-))
    |> transform(fn ast ->
      case ast do
        nil -> 1
        45 -> -1
      end
    end)
  end

  defp digits() do
    many(digit(), min: 1, ast: &List.to_string/1)
  end

  @doc """
  iex> Ergo.parse(Tokens.integer(), "12").ast
  12

  iex> Ergo.parse(Tokens.integer(), "-12").ast
  -12
  """
  def integer() do
    sequence(
      [
        optional(literal("-")),
        digits()
      ],
      ast: fn parts ->
        {integer, ""} =
          parts
          |> Enum.join()
          |> Integer.parse()

        integer
      end
    )
  end

  @doc """
  iex> Ergo.parse(Tokens.float(), "0.34").ast
  0.34

  iex> Ergo.parse(Tokens.float(), "-0.34").ast
  -0.34

  iex> Ergo.parse(Tokens.float(), "12.34").ast
  12.34

  iex> Ergo.parse(Tokens.float(), "-12.34").ast
  -12.34
  """
  def float() do
    sequence(
      [
        optional(literal("-")),
        digits(),
        literal("."),
        digits()
      ],
      ast: fn parts ->
        {float, ""} =
          parts
          |> Enum.join("")
          |> Float.parse()

        float
      end
    )
  end

  @doc """
  iex> Ergo.parse(Tokens.word(), "abc_").ast
  "abc_"

  iex> Ergo.parse(Tokens.word(), "ABC_").ast
  "ABC_"

  iex> Ergo.parse(Tokens.word(), "_ABC").ast
  "_ABC"

  iex> Ergo.parse(Tokens.word(), "1").ast
  Ergo.Nil
  """
  def word() do
    sequence(
      [
        transform(char([?a..?z, ?A..?Z, ?_]), &List.wrap/1),
        many(char([?a..?z, ?A..?Z, ?0..?9, ?_]), min: 0)
      ],
      ast: fn parts ->
        parts
        |> Enum.map(&List.to_string/1)
        |> Enum.join("")
      end
    )
  end

  @doc """
  iex> Ergo.parse(Tokens.atom(), ":abc").ast
  :abc

  iex> Ergo.parse(Tokens.atom(), "abc").ast
  Ergo.Nil

  iex> Ergo.parse(Tokens.atom(), ":1").ast
  Ergo.Nil

  iex> Ergo.parse(Tokens.atom(), "1").ast
  Ergo.Nil
  """
  def atom() do
    sequence(
      [
        ignore(literal(":")),
        word()
      ],
      ast: &String.to_atom(hd(&1))
    )
  end

  @doc """
  iex> Ergo.parse(Tokens.double_quoted_string(), ~s|"abc def"|).ast
  "abc def"

  iex> Ergo.parse(Tokens.double_quoted_string(), ~s|"123"|).ast
  "123"

  iex> Ergo.parse(Tokens.double_quoted_string(), ~s|"abc"v"|).ast
  "abc"
  """
  def double_quoted_string() do
    sequence(
      [
        ignore(char(?")),
        many(not_char(?")),
        ignore(char(?"))
      ],
      ast: &List.to_string/1
    )
  end

  @doc """
  iex> Ergo.parse(Tokens.whitespace(), "  ").ast
  "  "

  iex> Ergo.parse(Tokens.whitespace(), " a ").ast
  " "

  iex> Ergo.parse(Tokens.whitespace(), "\\n\\t ").ast
  "\n\t "
  """
  def whitespace(opts \\ []) do
    many(ws(), Keyword.merge([ast: &List.to_string/1], opts))
  end

  @doc """
  iex> Ergo.parse(Tokens.ignore_whitespace(), "  ").ast
  Ergo.Nil
  """
  def ignore_whitespace() do
    ignore(optional(whitespace(min: 1)))
  end

  @doc """
  iex> Application.put_env(:live_view_native_stylesheet, :annotations, true)
  iex> Ergo.parse(Tokens.variable(), "number").ast
  {:number, [file: nil, line: 1, module: nil], Elixir}

  iex> Application.put_env(:live_view_native_stylesheet, :annotations, true)
  iex> annotations = [{:file, nil}, {:line, 2}, {:module, nil}]
  iex> [Tokens.ignore_whitespace(), Tokens.variable()]
  ...> |> Ergo.Combinators.sequence()
  ...> |> Ergo.parse("\\n number")
  ...> |> then(&get_in(&1, [Access.key(:ast)]))
  [{:number, [file: nil, line: 2, module: nil], Elixir}]

  iex> Ergo.parse(Tokens.variable(), "1abc").ast
  Ergo.Nil
  """
  def variable() do
    transform_with_context(word(), fn old_ctx, new_ctx, variable_name ->
      {String.to_atom(variable_name), Context.create_annotation(old_ctx, new_ctx), Elixir}
    end)
  end

  @doc """
  iex> Ergo.parse(Tokens.literals(), "1").ast
  1

  iex> Ergo.parse(Tokens.literals(), "1.1").ast
  1.1

  iex> Ergo.parse(Tokens.literals(), "-1.1").ast
  -1.1
  """
  def literals() do
    choice(
      [
        float(),
        integer(),
        boolean(),
        nil_(),
        atom(),
        double_quoted_string()
      ],
      label: "literals"
    )
  end

  @doc """
  iex> Ergo.parse(Tokens.modifier_name(), "number").ast
  "number"
  """
  def modifier_name() do
    word()
  end

  @doc """
  iex> Ergo.parse(Tokens.module_name(), "Number").ast
  "Number"

  iex> Ergo.parse(Tokens.module_name(), "number").ast
  Ergo.Nil
  """
  def module_name() do
    sequence(
      [
        transform(char([?A..?Z]), &List.wrap/1),
        many(char([?a..?z, ?A..?Z, ?0..?9, ?_]), min: 0)
      ],
      ast: fn parts ->
        parts
        |> Enum.map(&List.to_string/1)
        |> Enum.join("")
      end,
      label: "Module name"
    )
  end
end
```

```elixir
defmodule Expressions do
  import Tokens
  import Ergo.Terminals
  import Ergo.Combinators
  alias Ergo.Context

  @doc """
  iex> Ergo.parse(Expressions.enclosed("(", Tokens.module_name(),")"), "(Color)").ast
  "Color"

  iex> Ergo.parse(Expressions.enclosed("(", Tokens.integer(),")"), "(12)").ast
  12

  iex> Ergo.parse(Expressions.enclosed("(", Tokens.module_name(),")"), "()").ast
  Ergo.Nil

  iex> ctx = Ergo.parse(Expressions.enclosed("(", Tokens.module_name(),")"), "Color")
  iex> {:error, [{error_id, _, error_message}|_]} = ctx.status
  iex> {ctx.ast, {error_id, error_message}}
  {Ergo.Nil, {:unexpected_token, "Expected #{Tokens.module_name().label}"}}
  """
  def enclosed(open, parser, close) do
    sequence(
      [
        ignore(literal(open)),
        parser,
        ignore(literal(close))
      ],
      err: fn ctx ->
        with %Context{status: {:error, _}} <- ctx do
          Context.add_error(ctx, :unexpected_token, "Expected #{parser.label}")
        end
      end
    )
    |> hoist()
  end

  #
  # Collections
  #

  @doc """
  iex> Ergo.parse(Expressions.comma_separated_list(Tokens.integer()), "1,2,   3").ast
  [1, 2, 3]

  iex> Ergo.parse(Expressions.comma_separated_list(Tokens.integer()), "1,2,   ").ast
  [1, 2]

  iex> Ergo.parse(Expressions.comma_separated_list(Tokens.literals()), "1,2, 1.3  ").ast
  [1, 2, 1.3]

  iex> Ergo.parse(Expressions.comma_separated_list(Tokens.literals()), "true, false, nil").ast
  [true, false, nil]
  """
  def comma_separated_list(parser, opts \\ []) do
    sequence(
      [
        ignore_whitespace(),
        parser,
        many(
          hoist(
            sequence([
              ignore_whitespace(),
              ignore(literal(",")),
              ignore_whitespace(),
              parser
            ])
          )
        ),
        ignore_whitespace()
      ],
      Keyword.merge(
        opts,
        ast: fn
          [first, rest] -> [first | rest]
          [[]] -> []
        end
      )
    )
  end

  # def key_value_children(generate_error?) do
  #   [
  #     {literal(error_parser: empty(), generate_error?: generate_error?),
  #      ~s'a number, string, nil, boolean or :atom'},
  #     {parsec(:key_value_list),
  #      ~s'a list of keyword pairs eg ‘[style: :dashed]’, ‘[size: 12]’ or ‘[lineWidth: lineWidth]’'},
  #     {parsec(:ime), ~s'an IME eg ‘Color.red’ or ‘.largeTitle’ or ‘Color.to_ime(variable)’'},
  #     {parsec(:nested_attribute), ~s'a modifier eg ‘foo(bar())’'},
  #     {variable(generate_error?: generate_error?),
  #      ~s|a variable defined in the class header eg ‘color_name’|}
  #   ]
  # end

  @doc """
  iex> Ergo.parse(Expressions.key_value_pair(), "a: 1").ast
  {:a, 1}

  iex> Ergo.parse(Expressions.key_value_pair(), ~s|a: "b"|).ast
  {:a, "b"}
  """
  def key_value_pair(opts \\ []) do
    sequence(
      [
        atom(word()),
        ignore(literal(":")),
        ignore(whitespace(min: 1)),
        choice(
          Keyword.get(opts, :choices, [
            literals()
          ])
        )
      ],
      ast: &List.to_tuple/1
    )
  end

  @doc """
  iex> Ergo.parse(Expressions.key_value_pairs(), "a: 1, b: 2").ast
  [a: 1, b: 2]

  iex> Ergo.parse(Expressions.key_value_pairs(), ~s'a: "b", c: "d"').ast
  [a: "b", c: "d"]
  """
  def key_value_pairs(opts \\ []) do
    comma_separated_list(key_value_pair(opts), opts)
  end

  @doc """
  iex> Ergo.parse(Expressions.key_value_list(), "[a: 1, b: 2]").ast
  [a: 1, b: 2]

  iex> Ergo.parse(Expressions.key_value_list(), ~s'[a: "b", c: "d"]').ast
  [a: "b", c: "d"]
  """
  def key_value_list(opts \\ []) do
    enclosed("[", key_value_pairs(opts), "]")
  end

  @doc """
  iex> Ergo.parse(Expressions.attr(), ~s'attr("placeholder")').ast
  {:__attr__, [], "placeholder"}

  iex> Ergo.parse(Expressions.attr(), ~s'attr(placeholder)').ast
  Ergo.Nil
  """
  def attr() do
    sequence(
      [
        ignore(literal("attr")),
        enclosed("(", double_quoted_string(), ")")
      ],
      ast: fn [attr] -> {:__attr__, [], attr} end
    )
  end
end
```

```elixir

```

```elixir
defmodule Blocks do
  import Tokens
  import Expressions
  import Ergo.Terminals
  import Ergo.Combinators
  import Combinators

  @doc """
  iex> Application.put_env(:live_view_native_stylesheet, :annotations, true)
  iex> Ergo.parse(Blocks.blocks(Tokens.integer()), ~s'"class_name" do 12 end\\n"class_name" do 12 end').ast
  [
      {["class_name",{:_target, [file: nil, line: 1, module: nil], Elixir}], 12},
      {["class_name",{:_target, [file: nil, line: 2, module: nil], Elixir}], 12}  
  ]

  iex> Application.put_env(:live_view_native_stylesheet, :annotations, true)
  iex> Ergo.parse(Blocks.blocks(Expressions.comma_separated_list(Tokens.integer())), ~s'"class_name" do 12, 13 end').ast
  [{["class_name", {:_target, [file: nil, line: 1, module: nil], Elixir}], [12, 13]}]

  iex> Application.put_env(:live_view_native_stylesheet, :annotations, true)
  iex> Ergo.parse(Blocks.blocks(Expressions.comma_separated_list(Tokens.integer())), ~s' "class_name", target: :watchos do 12, 13 end').ast
  [{["class_name", [file: nil, line: 1, module: nil, target: :watchos]], [12, 13]}]
  """

  def blocks(parser) do
    sequence([
      block(parser),
      many(
        hoist(
          sequence([
            ignore(whitespace(min: 1)),
            block(parser)
          ])
        )
      )
    ])
    |> transform(fn
      [first, rest] -> [first | rest]
    end)
  end

  @doc """
  iex> Application.put_env(:live_view_native_stylesheet, :annotations, true)
  iex> Ergo.parse(Blocks.block(Expressions.comma_separated_list(Tokens.integer())), ~s'"class_name" do 12, 13 end').ast
  {["class_name", {:_target, [file: nil, line: 1, module: nil], Elixir}], [12, 13]}

  iex> Application.put_env(:live_view_native_stylesheet, :annotations, true)
  iex> Ergo.parse(Blocks.block(Expressions.comma_separated_list(Tokens.integer())), ~s'"class_name", target: :watchos do 12, 13 end').ast
  {["class_name", [file: nil, line: 1, module: nil, target: :watchos]], [12, 13]}
  """

  def block(parser) do
    sequence(
      [
        ignore_whitespace(),
        block_head(),
        ignore_whitespace(),
        block_contents(parser)
      ],
      ast: &List.to_tuple/1
    )
  end

  @doc """
  iex> Ergo.parse(Blocks.block_head(), ~s'"class_name"').ast
  ["class_name", {:_target, [file: nil, line: 1, module: nil], Elixir}]

  iex> Ergo.parse(Blocks.block_head(), ~s'"class_name", target: :watchos').ast
  ["class_name", [file: nil, line: 1, module: nil, target: :watchos]]

  iex> Ergo.parse(Blocks.block_head(), ~s'"class_name" <> variable').ast
  [
    {:<>,
      [file: nil, line: 1, module: nil, context: Elixir, imports: [{2, Kernel}]],
      ["class_name", {:variable, [file: nil, line: 1, module: nil], Elixir}]
    },
    {:_target, [file: nil, line: 1, module: nil], Elixir}
  ]
  """
  def block_head() do
    class_opts =
      sequence([
        ignore(literal(",")),
        ignore_whitespace(),
        key_value_pairs()
      ])
      |> hoist()

    static_block_head = double_quoted_string()

    dynamic_block_head =
      sequence([
        double_quoted_string(),
        ignore_whitespace(),
        ignore(literal("<>")),
        ignore_whitespace(),
        variable()
      ])
      |> transform_with_context(fn old_ctx, new_ctx, [static_part, variable_part] ->
        annotation =
          Context.create_annotation(old_ctx, new_ctx) ++
            [context: Elixir, imports: [{2, Kernel}]]

        {:<>, annotation, [static_part, variable_part]}
      end)

    sequence([
      choice([dynamic_block_head, static_block_head]),
      ignore_whitespace(),
      optional(class_opts),
      ignore_whitespace()
    ])
    |> Combinators.transform_with_context(fn old_ctx, new_ctx, ast ->
      case ast do
        [class_name] ->
          [class_name, {:_target, Context.create_annotation(old_ctx, new_ctx), Elixir}]

        [class_name, block_opts] ->
          [class_name, Context.create_annotation(old_ctx, new_ctx) ++ block_opts]
      end
    end)
  end

  @doc """
  iex> Ergo.parse(Blocks.block_contents(Tokens.integer()), "do 12 end").ast
  12
  """
  def block_contents(parser) do
    sequence([
      ignore(literal("do")),
      ignore_whitespace(),
      lazy(parser),
      ignore_whitespace(),
      ignore(literal("end"))
    ])
    # |> hoist

    |> transform(fn
      [one] -> one
    end)
  end
end
```

```elixir
defmodule HelperFunctions do
  import Tokens
  import Expressions
  import Ergo.Terminals
  import Ergo.Combinators
  import Combinators

  @helper_functions [
    "to_atom",
    "to_integer",
    "to_float",
    "to_boolean",
    "camelize",
    "underscore"
  ]

  @doc """
  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(HelperFunctions.helper_function(), "to_float(number)").ast
  {Elixir, annotations, {:to_float, annotations, [{:number, annotations, Elixir}]}}
  """
  def helper_function() do
    function_name =
      @helper_functions
      |> Enum.map(&literal(&1))
      |> choice()
      |> atom()

    sequence([
      function_name,
      enclosed("(", variable(), ")")
    ])
    |> transform_with_context(fn old_ctx, new_ctx, [function_name | args] ->
      annotation = Context.create_annotation(old_ctx, new_ctx)
      {Elixir, annotation, {function_name, annotation, args}}
    end)
  end
end
```

```elixir
defmodule SwiftUI do
  import Tokens
  import Expressions
  import Ergo.Terminals
  import Ergo.Combinators
  import Combinators

  def ime_args_choices do
    [
      wrap(literals()),
      key_value_pairs(
        choices: [
          literals(),
          # key_value_list
          lazy(ime()),
          # nested_attribute
          variable()
        ]
      ),
      lazy(
        ime()
        |> transform(fn ast -> {:nested, ast} end, label: "nested_ime")
        |> wrap()
      ),
      # nested_attribute
      wrap(variable())
    ]
  end

  @doc """
  iex> Application.put_env(:live_view_native_stylesheet, :annotations, true)
  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), ".red").ast
  {:., annotations, [nil, :red]}

  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), "Color.red").ast
  {:., annotations, [:Color, :red]}

  # to_ime
  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), "to_ime(var)").ast
  {:., annotations, [nil, {Elixir, annotations, {:to_ime, annotations, [{:var, annotations, Elixir}]}}]}

  # to_ime with chaining
  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), "to_ime(color).foo").ast
  {:., annotations, [nil, {:., annotations, [{Elixir, annotations, {:to_ime, annotations, [{:color, annotations, Elixir}]}}, :foo]}]}

  # to_ime in the middle of a chain
  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), "Foo.to_ime(color).bar").ast
  {:., annotations, [:Foo, {:., annotations, [{Elixir, annotations, {:to_ime, annotations, [{:color, annotations, Elixir}]}}, :bar]}]}

  # ime with empty args
  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), ".foo.bar.baz().qux").ast
  {:., annotations, [nil, {:., annotations, [:foo, {:., annotations, [:bar, {:., annotations, [:baz, :qux]}]}]}]}

  # ime with args
  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), ".foo.bar.baz(1, 2).qux(3, 4)").ast
  {:., annotations, [nil, {:., annotations, [:foo, {:., annotations, [:bar, {:., annotations, [{:baz, annotations, [1, 2]}, {:qux,  annotations, [3, 4]}]}]}]}]}

  # ime with args
  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), "Foo.baz(1, 2).qux").ast
  {:., annotations, [:Foo, {:., annotations, [{:baz, annotations, [1, 2]}, :qux]}]}

  # ime with args
  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), "Foo.baz(var)").ast
  {:., annotations, [:Foo, {:baz, annotations, [{:var, annotations, Elixir}]}]}

  # Handle key_value_pairs
  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), "Foo.baz(color: .red)").ast
  {:., annotations, [:Foo, {:baz, annotations, [color: {:., annotations, [nil, :red]}]}]}

  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), "Foo.baz(color: .red(1))").ast
  {:., annotations, [:Foo, {:baz, annotations, [color: {:., annotations, [nil, {:red, annotations, [1]}]}]
  }]}

  # Handle variables
  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), "Foo.baz(color: var)").ast
  {:., annotations, [:Foo, {:baz, annotations, [color: {:var, annotations, Elixir}]}]}

  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), ".shadow(.thick)").ast
  {:., annotations, [nil, {:shadow, annotations, [{:., annotations, [nil, :thick]}]}]}

  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), "Color.shadow(.thick)").ast
  {:., annotations, [:Color, {:shadow, annotations, [{:., annotations, [nil, :thick]}]}]}

  iex> annotations = [{:file, nil}, {:line, 1}, {:module, nil}]
  iex> Ergo.parse(SwiftUI.ime(), "Color.red.shadow(.thick)").ast
  {:., annotations, [:Color, {:., annotations, [:red, {:shadow, annotations, [{:., annotations, [nil, :thick]}]}]}]}
  """
  def ime() do
    sequence(
      [
        choice([
          scoped_ime(),
          ime_helper_function(true),
          dotted_ime(true)
        ]),
        many(
          choice([
            # <...>.to_ime(color)
            ime_helper_function(false),
            # <...>.red
            dotted_ime(false)
          ])
        )
      ],
      ast: fn [first, rest] -> first ++ rest end,
      label: "ime"
    )
    |> transform(&chain_ime/1)
  end

  defp dotted_ime(is_initial) do
    sequence(
      [
        ignore(literal(".")),
        word(),
        ime_args()
      ],
      label: "dotted_ime"
    )
    |> transform_with_context(fn old_ctx, new_ctx, ast ->
      annotation = Context.create_annotation(old_ctx, new_ctx)

      ime_ast =
        case ast do
          [variable_name, args] ->
            {String.to_atom(variable_name), annotation, args}

          [variable_name] ->
            {:., annotation, [nil, String.to_atom(variable_name)]}
        end

      wrap_initial_ime(ime_ast, is_initial, annotation)
    end)
  end

  defp scoped_ime() do
    sequence(
      [
        module_name(),
        choice([
          ime_helper_function(false),
          dotted_ime(false)
        ])
      ],
      label: "scoped_ime"
    )
    |> transform_with_context(fn old_ctx, new_ctx, [module_name, ime_helper_function_ast] ->
      annotation = Context.create_annotation(old_ctx, new_ctx)
      wrap_ime_in_scope(module_name, ime_helper_function_ast, annotation)
    end)
  end

  defp ime_helper_function(is_initial) do
    function_name =
      if is_initial do
        ignore(literal("to_ime"))
      else
        ignore(literal(".to_ime"))
      end

    sequence(
      [
        function_name,
        enclosed(
          "(",
          variable(),
          ")"
        )
      ],
      label: "ime_helper_function"
    )
    |> transform_with_context(fn old_ctx, new_ctx, [variable] ->
      annotations = Context.create_annotation(old_ctx, new_ctx)

      wrap_initial_ime(
        {Elixir, annotations, {:to_ime, annotations, [variable]}},
        is_initial,
        annotations
      )
    end)
  end

  defp ime_args() do
    choice([
      ignore(literal("()")),
      ignore(
        sequence([
          not_lookahead(literal("(")),
          ignore_whitespace()
        ])
      ),
      enclosed("(", comma_separated_list(choice(ime_args_choices()), []), ")")
      |> transform(&Enum.concat/1)
    ])
  end

  defp wrap_initial_ime({:., _, [nil, ast]}, true, annotations),
    do: [{:., annotations, [nil, ast]}]

  defp wrap_initial_ime(ast, true, annotations), do: [{:., annotations, [nil, ast]}]
  defp wrap_initial_ime(ast, _, _), do: ast

  defp wrap_ime_in_scope(module_name, ime_ast, annotations) do
    [{:scope, annotations, String.to_atom(module_name)}, ime_ast]
  end

  # .foo.baz(.red)
  defp combine_ime_pair(outer, {prefix, annotations, [nested: args]}) do
    combine_ime_pair(outer, {prefix, annotations, [args]})
  end

  # Foo.baz
  defp combine_ime_pair({:scope, annotations, scope}, {:., _, [nil, inner]}) do
    {:., annotations, [scope, inner]}
  end

  # Foo.baz(1, 2)
  defp combine_ime_pair({:scope, annotations, scope}, inner) do
    {:., annotations, [scope, inner]}
  end

  # .foo.baz
  defp combine_ime_pair({:., annotations, [nil, outer]}, {:., _, [nil, inner]}) do
    {:., annotations, [nil, {:., annotations, [outer, inner]}]}
  end

  # .foo(1, 2).baz
  defp combine_ime_pair(
         {name, annotations, args},
         {:., _, [nil, inner]}
       )
       when is_atom(name) do
    {:., annotations, [{name, annotations, args}, inner]}
  end

  defp combine_ime_pair(
         {name, annotations, args},
         {:., _, [nil, inner]}
       )
       when is_atom(name) do
    {:., annotations, [{name, annotations, args}, inner]}
  end

  # .foo.baz(1, 2)
  defp combine_ime_pair({:., annotations, [nil, part]}, inner) do
    {:., annotations, [nil, {:., annotations, [part, inner]}]}
  end

  # .foo(1, 2).baz(1, 2)
  defp combine_ime_pair(
         {name, annotations, _} = ime,
         {name2, _, _} = ime2
       )
       when is_atom(name) and is_atom(name2) do
    {:., annotations, [ime, ime2]}
  end

  defp chain_ime([{:., annotations, [prefix, {name, _, [{:nested, sections}]}]}]) do
    {:., annotations, [prefix, {name, annotations, [sections]}]}
  end

  defp chain_ime(sections) do
    sections
    |> Enum.reverse()
    |> Enum.reduce(&combine_ime_pair/2)
  end
end
```

```elixir
defmodule Modifiers do
  import Expressions
  import Tokens
  import Ergo.Combinators
  import Ergo.Terminals
  import SwiftUI
  import HelperFunctions

  def modifiers() do
    modifiers =
      sequence([
        ignore_whitespace(),
        modifier(),
        sequence([
          ignore(whitespace(min: 1)),
          modifier()
        ])
        |> hoist()
        |> many()
      ])
      |> transform(fn
        [first, rest] -> [first | rest]
      end)

    # end_of_string =
    #   choice(
    #     [ws(), eoi(), literal("end")],
    #     err: fn ctx ->
    #       Ergo.Context.add_error(
    #         ctx,
    #         :unexpected_non_ws,
    #         "Unexpected character |#{String.first(ctx.input)}|"
    #       )
    #     end
    #   )

    # sequence([
    #   ignore_whitespace(),
    #   modifiers
    # ])
    # # sequence([modifiers, ignore(end_of_string)])
    # |> hoist()

    modifiers
  end

  def modifier() do
    sequence(
      [
        hoist(sequence([not_lookahead(literal("attr(")), modifier_name()])),
        enclosed(
          "(",
          comma_separated_list(
            choice([
              literals(),
              lazy(
                key_value_pairs(
                  choices: [
                    literals(),

                    # key_value_list
                    helper_function(),
                    lazy(ime()),
                    nested_attribute(),
                    variable()
                  ]
                )
              ),
              lazy(ime()),
              lazy(nested_attribute()),
              lazy(variable()),
              ignore_whitespace()
            ])
          ),
          ")"
        )
      ],
      label: "modifier"
    )
    |> Combinators.transform_with_context(fn
      old_ctx, new_ctx, [modifier_name, args] ->
        {String.to_atom(modifier_name), Context.create_annotation(old_ctx, new_ctx), args}
    end)
  end

  def nested_attribute() do
    choice([
      attr(),
      choice([
        literal("attr()"),
        literal("attr(")
      ])
      |> Combinators.halt("attr expects a string argument eg attr(\"placeholder\")"),
      helper_function(),
      lazy(modifier()),
      variable()
    ])
  end
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
# alias Ergo
# alias Ergo.Context
# import Ergo.Terminals
import Ergo.Terminals
import Tokens
import Ergo.Combinators

# Ergo.parse(Modifiers.modifier(), ~s'font(a: to_float(size))')
# |> Map.from_struct()
# |> Map.take([:status, :ast])

Ergo.parse(
  # Modifiers.modifier(),
  Modifiers.modifiers(),
  # "font(color: Color.red.shadow(.thick))"
  "font(color: Color.red.shadow(.thick))"
)
|> Map.from_struct()
|> Map.take([:status, :ast])

# Ergo.parse(
#   Blocks.blocks(Modifiers.modifiers()),
#   # Modifiers.modifiers(),
#   """
#           "color-red", target: :watchos do
#           color(.red)
#         end
#   """
# )
# |> Map.from_struct()
# |> Map.take([:status, :ast])
```

```elixir
defmodule Jetpack do
  # 24.dp
  # https://developer.android.com/jetpack/compose/modifiers-list
  # Modifier
  #     .matchParentSize()
  #     .background(Color.LightGray)
  # modifier = Modifier.weight(2f)
end
```

<!-- livebook:{"reevaluate_automatically":true} -->

```elixir
ExUnit.start(autorun: false, exclude: [:skip])

defmodule LargeTest2 do
  use ExUnit.Case
  # doctest SwiftClass
  # alias SwiftClass.Helpers.HelperFunctionsTest

  def parse(input) do
    # Parser.invoke(parser)
    %Ergo.Context{status: :ok, ast: ast} =
      Modifiers.modifiers()
      |> transform(fn
        [one] -> one
        not_one -> not_one
      end)
      |> Ergo.parse(input)

    ast
  end

  def parse_class_block(input) do
    %Ergo.Context{status: :ok, ast: ast} =
      Ergo.parse(Blocks.blocks(Modifiers.modifiers()), input)

    ast
  end

  # describe "benchmark" do
  #   test "parse long stylesheet" do
  #     file = File.read!("test/helpers/classes.swiftui.style")

  #     for _ <- 1..100 do
  #       file
  #       |> SwiftClass.parse_class_block()
  #     end
  #   end
  # end

  describe "parse/1" do
    Application.put_env(:live_view_native_stylesheet, :annotations, false)

    test "parses modifier function definition" do
      input = "bold(true)"
      output = {:bold, [], [true]}

      assert parse(input) == output
    end

    # test "parses modifier function definition(2)" do
    #   input = "1(true)"

    #   assert {:error, ":1: error:" <> _, _, _, _, _} =
    #            SwiftClass.parse(input)
    # end

    test "parses modifier with multiple arguments" do
      input = "background(\"foo\", \"bar\")"
      output = {:background, [], ["foo", "bar"]}

      assert parse(input) == output

      # space at start and end
      input = "background( \"foo\", \"bar\" )"
      assert parse(input) == output

      # space at start only
      input = "background( \"foo\", \"bar\")"
      assert parse(input) == output

      # space at end only
      input = "background(\"foo\", \"bar\" )"
      assert parse(input) == output
    end

    test "parses single modifier with atom as IME" do
      input = "font(.largeTitle)"

      output = {:font, [], [{:., [], [nil, :largeTitle]}]}

      assert parse(input) == output
    end

    test "parses chained IMEs" do
      input = "font(color: Color.red)"

      output = {:font, [], [[color: {:., [], [:Color, :red]}]]}

      assert parse(input) == output

      input = "font(color: Color.red.shadow(.thick))"

      output =
        {:font, [],
         [[color: {:., [], [:Color, {:., [], [:red, {:shadow, [], [{:., [], [nil, :thick]}]}]}]}]]}

      assert parse(input) == output
    end

    test "parses multiple modifiers" do
      input = "font(.largeTitle) bold(true) italic(true)"

      output = [
        {:font, [], [{:., [], [nil, :largeTitle]}]},
        {:bold, [], [true]},
        {:italic, [], [true]}
      ]

      assert parse(input) == output
    end

    test "parses complex modifier chains" do
      input = "color(color: .foo.bar.baz(1, 2).qux)"

      output =
        {:color, [],
         [
           [
             color:
               {:., [],
                [nil, {:., [], [:foo, {:., [], [:bar, {:., [], [{:baz, [], [1, 2]}, :qux]}]}]}]}
           ]
         ]}

      assert parse(input) == output
    end

    test "parses multiline" do
      input = """
      font(.largeTitle)
      bold(true)
      italic(true)
      """

      output = [
        {:font, [], [{:., [], [nil, :largeTitle]}]},
        {:bold, [], [true]},
        {:italic, [], [true]}
      ]

      assert parse(input) == output
    end

    test "parses string literal value type" do
      input = "foo(\"bar\")"
      output = {:foo, [], ["bar"]}

      assert parse(input) == output
    end

    test "parses numerical types" do
      input = "foo(1, -1, 1.1)"
      output = {:foo, [], [1, -1, 1.1]}

      assert parse(input) == output
    end

    test "parses key/value pairs" do
      input = ~s|foo(bar: "baz", qux: .quux)|
      output = {:foo, [], [[bar: "baz", qux: {:., [], [nil, :quux]}]]}

      assert parse(input) == output
    end

    test "parses bool and nil values" do
      input = "foo(true, false, nil)"
      output = {:foo, [], [true, false, nil]}

      assert parse(input) == output
    end

    test "parses Implicit Member Expressions" do
      input = "color(.red)"
      output = {:color, [], [{:., [], [nil, :red]}]}

      assert parse(input) == output
    end

    test "parses nested function calls" do
      input = ~s|foo(bar("baz"))|
      output = {:foo, [], [{:bar, [], ["baz"]}]}

      assert parse(input) == output
    end

    test "parses attr value references" do
      input = ~s|foo(attr("bar"))|
      output = {:foo, [], [{:__attr__, [], "bar"}]}

      assert parse(input) == output
    end
  end

  describe "class block parser" do
    test "parses a simple block" do
      input = """
      "red-header" do
        color(.red)
        font(.largeTitle)
      end
      """

      output = [
        {
          ["red-header", {:_target, [], Elixir}],
          [
            {:color, [], [{:., [], [nil, :red]}]},
            {:font, [], [{:., [], [nil, :largeTitle]}]}
          ]
        }
      ]

      assert parse_class_block(input) == output
    end

    test "parses a complex block" do
      input = """
      "color-" <> color_name do
        foo(true)
        color(color_name)
        bar(false)
      end
      """

      output = [
        {[
           {:<>, [context: Elixir, imports: [{2, Kernel}]],
            ["color-", {:color_name, [], Elixir}]},
           {:_target, [], Elixir}
         ],
         [
           {:foo, [], [true]},
           {:color, [], [{:color_name, [], Elixir}]},
           {:bar, [], [false]}
         ]}
      ]

      assert parse_class_block(input) == output
    end

    test "parses a complex block (2)" do
      input = """
      "color-" <> color do
        color(color)
      end
      """

      output = [
        {[
           {:<>, [context: Elixir, imports: [{2, Kernel}]], ["color-", {:color, [], Elixir}]},
           {:_target, [], Elixir}
         ], [{:color, [], [{:color, [], Elixir}]}]}
      ]

      assert parse_class_block(input) == output
    end

    test "parses multiple blocks" do
      input = """
      "color-" <> color_name do
        foo(true)
        color(color_name)
        bar(false)
      end

      "color-red" do
        color(.red)
      end
      """

      output = [
        {[
           {:<>, [context: Elixir, imports: [{2, Kernel}]],
            ["color-", {:color_name, [], Elixir}]},
           {:_target, [], Elixir}
         ],
         [
           {:foo, [], [true]},
           {:color, [], [{:color_name, [], Elixir}]},
           {:bar, [], [false]}
         ]},
        {
          ["color-red", {:_target, [], Elixir}],
          [{:color, [], [{:., [], [nil, :red]}]}]
        }
      ]

      assert parse_class_block(input) == output
    end

    test "can take optional target in definition" do
      input = """
        "color-red", target: :watchos do
          color(.red)
        end
      """

      output = [
        {
          ["color-red", [target: :watchos]],
          [{:color, [], [{:., [], [nil, :red]}]}]
        }
      ]

      assert parse_class_block(input) == output
    end
  end

  describe "helper functions" do
    test "to_atom" do
      input = "buttonStyle(style: to_atom(style))"

      output = {:buttonStyle, [], [[style: {Elixir, [], {:to_atom, [], [{:style, [], Elixir}]}}]]}

      assert parse(input) == output
    end

    test "to_integer" do
      input = "frame(height: to_integer(height))"

      output = {:frame, [], [[height: {Elixir, [], {:to_integer, [], [{:height, [], Elixir}]}}]]}

      assert parse(input) == output
    end

    test "to_float" do
      input = "kerning(kerning: to_float(kerning))"

      output =
        {:kerning, [], [[kerning: {Elixir, [], {:to_float, [], [{:kerning, [], Elixir}]}}]]}

      assert parse(input) == output
    end

    test "to_boolean" do
      input = "hidden(to_boolean(is_hidden))"

      output = {:hidden, [], [{Elixir, [], {:to_boolean, [], [{:is_hidden, [], Elixir}]}}]}

      assert parse(input) == output
    end

    test "camelize" do
      input = "font(family: camelize(family))"

      output = {:font, [], [[family: {Elixir, [], {:camelize, [], [{:family, [], Elixir}]}}]]}

      assert parse(input) == output
    end

    test "underscore" do
      input = "font(family: underscore(family))"

      output = {:font, [], [[family: {Elixir, [], {:underscore, [], [{:family, [], Elixir}]}}]]}

      assert parse(input) == output
    end

    # test "additional helper function names can be provided" do
    #   input = "to_ime(family)"

    #   output = {Elixir, [], {:to_ime, [], [{:family, [], Elixir}]}}

    #   assert {:ok, [result], _, _, _, _} = HelperFunctionsTest.helper_functions(input)
    #   assert result == output
    # end

    # test "can't parse unknown helper functions" do
    #   input = "to_unknown(family)"

    #   assert {:error, "expected a 1-arity helper function (to_atom, " <> _, _, _, _, _} =
    #            HelperFunctionsTest.helper_functions(input)
    # end
  end
end

ExUnit.run()
```

```elixir
inspect = fn input, line ->
  result =
    Modifiers.modifiers()
    |> transform(fn
      [one] -> one
      not_one -> not_one
    end)
    |> Ergo.parse(input)

  case result do
    %Ergo.Context{status: :ok, ast: ast} ->
      IO.puts(inspect(result))

    %Ergo.Context{status: {:error, errors}} ->
      IO.puts(inspect(errors))
  end
end

inspect.("abc(def: 11, b: [lineWidth a, l: 2a]", __ENV__.line)

# inspect.("blue", __ENV__.line)
# inspect.("1(.red)", __ENV__.line)
# inspect.("font(Color.largeTitle.)", __ENV__.line)
# inspect.("abc(def: 11, b: [lineWidth: 1lineWidth])", __ENV__.line)
# inspect.("font(.largeTitle) {", __ENV__.line)

# inspect.("font(.)))red)", __ENV__.line)
# inspect.("abc(def: 11, b: [lineWidth: 1lineWidth])", __ENV__.line)
# # Should point to 2a
# inspect.("abc(def: 11, b: [lineWidth: a, l: 2a])", __ENV__.line)
```

```elixir
List.to_string(["a", "b"])
```
